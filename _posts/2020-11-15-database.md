---
layout: post
title: "数据库知识点总结"
date: 2021-11-15
tag: 数据库,八股
---   
## 数据库范式

1. 第一范式：最基本的范式，如果数据库表中所有字段值都是**不可分解的原子值**，就说明该数据库表满足第一范式
2. 第二范式：关系模式必须满足第一范式，并且所有非主属性都完全依赖于主码。注意，符合第二范式的关系模型可能还存在数据冗余，更新异常等问题。eg：关系模型（学号、姓名、专业编号、专业名称）中，学号->姓名，而专业编号->专业名称，不满足数据库第二范式
3. 第三范式：关系模型满足第二范式，所有非主属性对任何候选关键字都不存在传递依赖。即**每个属性都跟主键又直接关系而不是间接关系**。eg：关系模型（学号、姓名、年龄、性别、所在院校、院校地址）院校地址和学号不存在直接关系，所以不满足第三范式


## MySQL架构
应用层：负责相应客户端请求，建立连接，返回数据
逻辑层：包括 SQK 接口，解析器，优化器，返回数据
引擎层：InnoDB，MyISAM
物理层：负责文件存储，日志等

## 简述SQL语言执行过程
1. 客户端首先通过连接器进行身份认证和权限相关
2. 如果执行查询语句的时候，先查询缓存，如果命中缓存，立刻返回存储在缓存中的结果，否则进入下一阶段
3. 服务器端进行SQL解析、预处理、再由优化器生成对应的执行计划
4. MySQL 根据优化器生成的执行计划，调用存储引擎的 API 来执行查询
5. 将结果返回给客户端（**增量、逐步返回的过程**）
   
[这篇博文讲的很详细](https://segmentfault.com/a/1190000015979741)
![Image](https://pic4.zhimg.com/80/v2-170e9ada6c5d1fdc72c0fe0e98780899.png)


## 事务

事务指的是满足 ACID 特性的一组操作，可以通过 commit 提交一个事务，也可以使用 rollback 进行回滚

### ACID

1. 原子性（Atomicity）
   
事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚

1. 一致性（Consistency）

数据库在事务执行前后都保持一致性状态，所有事物对同一个数据的读取结果都是相同的

3. 隔离性（Isolation）

一个事务在最后提交之前，对其他事务都是不可见的

4. 持久性（Durability）

一旦事务提交，其所作的修改将会永久保存到数据库中，即使系统发生崩溃，事务执行的结果也不会丢失

![Image](https://pic4.zhimg.com/80/v2-ef5e12d657f4437cd2ffe1bc2a4a5e34.png)


## 数据库索引

### 概念

索引是对数据库表中一个或多个列的值进行排序的数据结构，以协助快速查询，更新数据库表中数据。索引的实现通常使用B_TREE及其变种。索引加速了数据访问，因为存储引擎不会再去扫描整张表得到需要的数据；相反，它从根节点开始，根节点保存了子节点的指针，存储引擎会根据指针快速寻找数据。

### 索引的优点

1. **大大加快数据的检索速度**
2. 加速表和表之间的连接
3. 在使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间
4. 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性

### 什么情况下设置了索引但无法使用

1. LIKE 语句模糊匹配
2. OR 语句前后没有同时使用索引
3. 数据类型出现隐式转化（如varchar不加单引号可能会自动转换成int型）
4. 对于多列索引，必须满足 **最左匹配原则**（多列索引 col1,col2,col3，则索引生效的情形包括col1 或 col1,col2 或 col1,col2,col3)

### 什么样的情况适合创建索引

1. 经常作查询选择的字段
2. 经常作表连接的字段
3. 经常出现在 order by、group by、disticnt 后面的字段

### 创建索引时需要注意什么

1. **非空字段**： 应该指定列为 NOT NULL，除非你想存储 NULL。在 MySQL 中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值
2. **取值离散大的字段** ：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高
3. **索引字段越小越好** ：数据库的数据存储以页为单位，一页存储的数据越多一次IO操作获取的数据越大效率越高


## 锁

### MySQL 中按粒度的锁分类


1. 表级锁: 对当前操作的整张表加锁,实现简单，加锁快，但并发能力低。

2. 行锁: 锁住某一行，如果表存在索引，那么记录锁是锁在索引上的，如果表没有索引，那么 InnoDB 会创建一个隐藏的聚簇索引加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。

3. Gap 锁：也称为间隙锁: 锁定一个范围但不包括记录本身。其目的是为了防止同一事物的两次当前读出现幻读的情况。

4. Next-key Lock： 行锁+gap锁

### 乐观锁和悲观锁

### 排他锁和共享锁

共享锁 （share lock）又称**读锁**（S锁）。相互不阻塞，多个事务对于同一数据可以共享一把锁，可以访问到数据，但是不能修改 

排他锁（exclusive lock）又称**写锁**（X锁）。会阻塞其他的写锁和读锁（不能和其他的锁共存），确保在给定时间内只有一个用户能执行写入并防止其他用户读取正在写入的同一资源

> 对于排他锁，并不是说它锁上一行数据之后其他事务就不能读取和修改这一行了，而是不能再在这一行上加其他的锁。 MYSQL InnoDB 引擎默认的修改数据语句（update、delete、insert都会自动给涉及到的行加上一个排他锁，select 语句默认不会加任何锁，所以**普通的 select 是可以的**，如果加排他锁可以用`select ...for update`, 如果加共享锁可以用`select ... lock in share mode`



### 如何解决数据库死锁

  1. 直接等待当查询的时间到达锁等待超时的设定后放弃锁请求。（InnoDB 中，innodb_lock_wait_timeout 的默认值是50s，这意味着当出现死锁时，需要等待 50s 第一个被锁住的线程才会超时退出，这个时间往往是无法接受的）
  2. 主动发起死锁检测，发现死锁后，主动回滚到死锁链条中的某一个事务，让其他事务得以继续执行