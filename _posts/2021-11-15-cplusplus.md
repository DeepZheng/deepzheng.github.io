---
layout: post
title: "C++知识点总结"
date: 2021-11-15
tag: C++
---  

1. static 关键字在 C 和 C++ 中各自有哪些不同用法
2. volatile 关键字
3. union 是什么，有什么用
4. 面向对象有哪些基本特性
5. map 和 unordered_map
6. 右值引用和左值引用
7. 构造函数能不能抛出异常？析构函数呢
8.  C++ 类型转换


### 从源代码到可执行程序，中间的过程
编译分为四个过程：编译预处理，编译优化，汇编，链接

* **编译预处理**：处理以 # 开头的指令
* **编译优化**：将源码 .cpp 文件翻译成 .s汇编代码
* **汇编**：将汇编代码 .s 翻译成 .o机器指令文件
* **链接**：汇编程序生成的 .o 目标文件，并不会立即执行，因为可能 .cpp 文件中的函数引用了另一个 .cpp 文件中定义的符号或者调用某个库函数中的函数。链接的目的就是将这些文件对应的目标文件连接成一个整体，从而生成可执行的 .exe 文件
![Image](https://pic4.zhimg.com/80/v2-54fa01e15a44a8359f8a112a533920a2.png)

链接分为两种：
* **静态链接**：代码从其所在的静态链接库中拷贝到最终的可执行程序中，在该程序被执行时，这些代码会被装入到该进程的虚拟空间地址中

* **动态链接**：代码被放到动态链接库或共享对象的某个目标文件中，链接程序只是在最终的可执行程序记录共享对象的名字等一些信息。在程序执行时，动态链接库的全部内容会被映射到运行时相应进行的虚拟地址空间

### 栈和堆

* 栈：由操作系统分配，存放函数参数，局部变量等
  
  栈在内存中是连续的一块空间

* 堆：由程序员主动申请，如果程序结束还没有释放，操作系统会自动回收

> 堆内存不连续
> 
> 在 malloc 空间的时候，申请的空间大小不一，容易造成碎片。使用 malloc 的时候系统内部有一个空闲内存映射表，系统会自动寻找合适大小的空间分配

### 内存泄露

内存泄漏是指你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。一个盘子用尽各种方法只能装4个果子，你装了5个，结果掉倒地上不能吃了。这就是溢出！比方说栈，栈满时再做进栈必定产生空间溢出，叫上溢，栈空时再做退栈也产生空间溢出，称为下溢。就是分配的内存不足以放下数据项序列,称为内存溢出



### 智能指针

在 c++ 中，动态内存的管理是由 new 和 delete 完成的。通过 new 在堆中动态分配一块空间并返回一个指向这个区域的指针，delete 用来销毁对象并释放相对应的内存。但是如果使用之后忘记 delete，就容易出现内存泄露，或者在尚有引用的情况下就释放内存，就会产生非法引用的指针

所以为了更加安全地使用动态内存，C++11 引入智能指针。智能指针的行为类似指针，最重要的区别是它会对指针进行自动管理，就不需要手动地 delete 指针

* shared_ptr
  
  顾名思义，shared_ptr 允许多个指针共享一个对象

```
  //初始化方式
  shared_ptr<T>p1;    //默认初始化的智能指针保存着一个空指针
  shared_ptr<T>p(q);  //p 是 q 的拷贝，此操作会递增 q 中的计数器
  p1 = q;  //此操作会递减 p1 的引用计数，递增 q 的引用技术；若 p 的引用计数变为 0， 则将其管理的原内存释放
```
  **make_shared**:
  最安全的分配和使用动态内存的方法就是调用一个名为 make_shared 的标准库函数，此函数在动态内存中分配一个对象并初始化它，返回指向此对象的 shared_ptr
  ```C++
  shared_ptr<int>p3 = make_shared<int>(42);
  shared_ptr<int>p4 = make_shared<string>(10,'a');
  shared_ptr<int>p5 = make_shared<int>();
  ```

  每个 shared_ptr 都有一个关联的计数器，通常称为**引用计数**，无论何时我们拷贝一个 shared_ptr，计数器都会递增。当我们给 shared_ptr 赋予一个新值或者 shared_ptr 被销毁(例如一个局部的 sharedptr 离开其作用域时)，计数器都会递减，一旦 shared_ptr 的计数器变为 0，他就会自动释放自己所管理的对象

* unique_ptr
  
  unique_ptr 则独占所指向的对象。由于一个 unique_ptr 拥有它指向的对象，因此 unique_ptr 不支持普通的拷贝或赋值操作

  ```C++
  unique_ptr<T> u1;     //默认初始化的智能指针保存着一个空指针
  ```
  虽然我们不能拷贝或者赋值，但是可以通过调用 reset 或 release 将指针所有权从一个（非const） unique_ptr 转移给另一个
  ```C++
  unique_ptr<string> p2 (p1.release());     //release 将p1置为空
  unique_ptr<string> p3 (new string ("deep"));
  p3.reset(p2.release());                   //reset 释放了 p3 原来指向的内存，release 将p2 置为空       
  ```
* weak_ptr

  weak_ptr 是一种不控制所指向对象生存期的智能指针，它指向一个由 **shared_ptr** 管理的对象，将一个 weak_ptr 绑定到 shared_ptr 不会改变 shared_ptr 的计数器。一旦最后一个指向对象的 shared_ptr 被销毁，对象就会被释放，即使有 weak_ptr 指向对象，还是会被销毁 、


### vector 扩容机制

vector 在初始化的时候，会在内存中分配一块连续的空间，大小不小于初始化时内容的大小。由于 vector 支持变长，在添加元素时若超过原有容器 capacity，就需要扩容。

此时 vector 会另外再找一块连续的内存空间，将容量变大（增加倍数不一定，由编译器定），并将原来的元素都复制到新空间中去。所以原来的迭代器就无法使用了

* reserve 函数实现扩容只会改变 vector 的 capacity，不会改变 size
* size 会改变容器的 capacity 和 size 大小，并且创建对象，如果申请的 n 比原来的 size 小，多出的元素会被丢弃掉

