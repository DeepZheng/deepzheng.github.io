I"Ú+<blockquote>
  <p>æœ¬æ–‡ä¸ºæ–¯å¦ç¦å¤§å­¦è®¡ç®—æœºç½‘ç»œè¯¾ç¨‹ CS144 ç¼–ç¨‹ä»»åŠ¡ Lab Assignment 3 çš„å­¦ä¹ å°ç»“</p>

  <p>å®˜ç½‘ https://cs144.github.io/</p>

  <p>Lab 3 æ–‡æ¡£ https://cs144.github.io/assignments/lab3.pdf</p>

  <p>ä¸ªäººå®éªŒå¤‡ä»½ä»£ç  https://github.com/deepzheng/sponge</p>
</blockquote>

<hr />

<h2 id="the-tcp-sender">The TCP Sender</h2>

<p>æˆ‘ä»¬æ‰€å®ç°çš„ TCPSender éœ€è¦å…·å¤‡å¦‚ä¸‹åŠŸèƒ½ï¼š</p>

<ul>
  <li>è·Ÿè¸ªæ¥æ”¶ç«¯çš„çª—å£å¤§å°ï¼Œå¹¶æ ¹æ®æ¥æ”¶ç«¯çš„çª—å£å°ºå¯¸è°ƒæ•´å‘é€é€Ÿç‡ï¼ˆ<strong>æµé‡æ§åˆ¶</strong>ï¼‰</li>
  <li>å°½å¯èƒ½å¡«å……å‘é€çª—å£å¹¶å‘é€æŠ¥æ–‡æ®µç›´åˆ°çª—å£å·²æ»¡æˆ–å‘é€æ•°æ®å®Œæˆ</li>
  <li>è·Ÿè¸ªå·²å‘é€ä½†å°šæœªè¢«æ¥æ”¶çš„æŠ¥æ–‡æ®µï¼Œå¹¶åœ¨åˆé€‚çš„æ—¶æœºé‡ä¼ ï¼ˆ<strong>è¶…æ—¶é‡ä¼ </strong>ï¼‰</li>
</ul>

<p>æœ¬æ¬¡ä»»åŠ¡æˆ‘ä»¬ä¸»è¦éœ€è¦å®Œæˆä»¥ä¸‹å‡ ä¸ªå‡½æ•°</p>

<h3 id="fill_window">fill_window()</h3>

<p>å°†è¾“å…¥çš„ ByteStream å°½å¯èƒ½å¡«å……åˆ°å‘é€çª—å£ä¸­ï¼Œ</p>

<h3 id="ack_received-const-wrappingint32-ackno-const-uint16_t-window_size">ack_received( const WrappingInt32 ackno, const uint16_t window_size)</h3>

<p>ä»æ¥æ”¶è€…å‘é€æ¥çš„ç¡®è®¤æŠ¥æ–‡ä¸­ï¼Œè·å–ç¡®è®¤åºåˆ—å·å’Œæ¥æ”¶çª—å£å¤§å°ä¾¿äº Sender åˆ é™¤é©»ç•™åœ¨é˜Ÿåˆ—ä¸­å·²ç»å‘é€ä½†å°šæœªè¢«ç¡®è®¤çš„æŠ¥æ–‡ï¼Œå¹¶è°ƒæ•´å‘é€çª—å£çš„å¤§å°</p>

<h3 id="tick-const-size_t-ms_since_last_tick-">tick( const size_t ms_since_last_tick )</h3>

<p>å”¯ä¸€çš„è°ƒç”¨æ¥å£æ¥æ£€æŸ¥å·²å‘é€ä½†å°šæœªè¢«æ¥æ”¶çš„æŠ¥æ–‡æ˜¯å¦å‘ç”Ÿè¶…æ—¶ï¼Œè‹¥è¶…æ—¶å°†æ‰§è¡Œé‡ä¼ </p>

<h3 id="send_empty_segment">send_empty_segment()</h3>

<p>å‘é€ä¸€æ®µå­—èŠ‚é•¿åº¦ä¸º 0 çš„æŠ¥æ–‡æ®µï¼Œè¿™æ ·çš„ç©ºæŠ¥æ–‡æ®µä¸éœ€è¦è¢«æ ‡è®°ä¸ºæœªç¡®è®¤æ®µï¼ˆoutstandingï¼‰å¹¶ä¸”ä¸éœ€è¦å¯åŠ¨è®¡æ—¶å™¨ä¹Ÿä¸ä¼šè¢«é‡ä¼ </p>

<h3 id="ä»¥ä¸‹æ˜¯å®ç°æ€è·¯ä»¥åŠä¸€äº›å°ç»†èŠ‚">ä»¥ä¸‹æ˜¯å®ç°æ€è·¯ä»¥åŠä¸€äº›å°ç»†èŠ‚</h3>

<p>ç”¨é˜Ÿåˆ—å­˜å‚¨å‘é€æŠ¥æ–‡æ®µï¼ŒåŒæ ·ç”¨ä¸€ä¸ªé˜Ÿåˆ—æ¥å­˜å‚¨å‘é€åç­‰å¾…è¢«ç¡®è®¤çš„æŠ¥æ–‡æ®µï¼ˆç©ºæŠ¥æ–‡æ®µä¸éœ€è¦è¢«æ¨å…¥è¯¥é˜Ÿåˆ—ï¼‰</p>

<p>åœ¨è¿æ¥å»ºç«‹æ—¶ï¼ŒTCPSender ä¼šå‘é€ä¸€ä¸ªåªå«æœ‰ SYN ä¿¡å·çš„æŠ¥æ–‡æ®µï¼Œä¸”è¯¥æŠ¥æ–‡æ®µåªç”¨äºæ¡æ‰‹ï¼Œè€Œ FIN ä¿¡å·å¯ä»¥åŒ…å«åœ¨å«æœ‰æ•°æ®çš„æŠ¥æ–‡æ®µä¸­ã€‚å½“æ¥æ”¶ç«¯æ¥æ”¶åˆ° FIN ä¿¡å·ä¸”æˆåŠŸè¿”å›å¯¹äº FIN çš„ç¡®è®¤åï¼Œè¿æ¥æ‰æ­£å¼å…³é—­ã€‚å› æ­¤ï¼Œå½“ SYN å°šæœªè¢«ç¡®è®¤ä¸”çª—å£é 0 æ—¶ï¼Œæ­¤æ—¶ä»ç„¶ä¸èƒ½å‘é€æ•°æ®</p>

<p>TCP å®è¡Œçš„æ˜¯<strong>ç´¯è®¡ç¡®è®¤</strong>ï¼Œå³ TCP åªç¡®è®¤è¯¥æµä¸­è‡³ç¬¬ä¸€ä¸ªä¸¢å¤±å­—èŠ‚ä¸ºæ­¢çš„å­—èŠ‚ã€‚ åœ¨æ¥æ”¶åˆ°ç¡®è®¤åºå· ackno åï¼Œæ„å‘³ç€åœ¨è¯¥åºå·å‰çš„æ‰€æœ‰å­—èŠ‚å·²ç»è¢«ç¡®è®¤ï¼Œå°±å¯ä»¥æŠŠè¿™äº›å­—èŠ‚åœ¨ç­‰å¾…é˜Ÿåˆ—ä¸­åˆ é™¤ã€‚åŒæ—¶ï¼Œå¦‚æœå‘ç”Ÿè¶…æ—¶é‡ä¼ ï¼Œåªéœ€è¦é‡ä¼ ç­‰å¾…é˜Ÿåˆ—é˜Ÿå¤´çš„æŠ¥æ–‡å³å¯</p>

<p>å¯¹äºå‘é€æ–¹çš„ windows size ï¼Œè¿˜æœ‰ä¸€ä¸ªé—®é¢˜éœ€è¦æ³¨æ„ã€‚å°±æ˜¯å½“æ¥æ”¶ç«¯ç¼“å­˜å·²æ»¡ï¼ˆå³çª—å£å¤§å°ä¸º 0 ï¼‰æ—¶ï¼Œå°†è¿™ä¸€ä¿¡æ¯è¿”å›ç»™å‘é€æ–¹ï¼Œå¹¶ä¸”åˆšå¥½å‘é€æ–¹ä¹Ÿæ²¡æœ‰ä»»ä½•æ•°æ®è¦å‘é€ã€‚è¿™æ—¶å€™å°±ä¼šå‡ºç°ä¸€ä¸ªå¾ˆå°´å°¬çš„æƒ…å†µï¼Œå°±æ˜¯å‘é€æ–¹æ¥æ”¶ä¸åˆ°ä»»ä½•æ¥è‡ªæ¥æ”¶ç«¯çª—å£å¤§å°å˜åŒ–çš„é€šçŸ¥ï¼ˆå› ä¸º TCP ä»…å½“æœ‰æ•°æ®æˆ–è€…ç¡®è®¤è¦å‘æ—¶æ‰ä¼šå‘é€æŠ¥æ–‡æ®µï¼Œè€Œçª—å£å¤§å°çš„ä¿¡æ¯æ˜¯é™„åœ¨è¿™äº›æŠ¥æ–‡æ®µä¸­çš„ï¼‰ã€‚æ‰€ä»¥æ­¤æ—¶å‘é€ç«¯ç›¸å½“äºè¢«é˜»å¡äº†ã€‚å¯¹äºè¿™ç§æƒ…å†µï¼ŒTCP è§„å®šå°†çª—å£å¤§å°è§†ä¸º 1 ï¼Œåœ¨æ¥æ”¶ç«¯çª—å£ä¸º 0 æ—¶ç»§ç»­å‘é€å¤§å°ä¸º 1 çš„æŠ¥æ–‡æ®µã€‚è¿™äº›æŠ¥æ–‡æ®µæœ€ç»ˆå°†è¢«æ¥æ”¶å¹¶è¿”å›æ–°çš„çª—å£å¤§å°ã€‚æ‰€ä»¥åœ¨ä»£ç å®ç°ä¸­åŠ å…¥äº† <code class="language-plaintext highlighter-rouge">_win_zero_flag</code> å˜é‡</p>

<pre><code class="language-C++">    if (_win_size == 0) {
        _win_zero_flag = true;
        _win_size = 1;
    } else {
        _win_zero_flag = false;
    }
</code></pre>
<p>å½“åé¦ˆå›æ¥çš„çª—å£å¤§å°ä¸º 0 æ—¶ï¼Œå¼ºåˆ¶è°ƒæ•´ä¸º 1 ï¼Œå¹¶å°† <code class="language-plaintext highlighter-rouge">_win_zero_flag</code>è®¾ä¸º true ç”¨äºè¾…åŠ©åˆ¤æ–­åœ¨è¶…æ—¶é‡ä¼ æ—¶æ˜¯å¦éœ€è¦å°†é‡ä¼ æ—¶é—´å€å¢</p>

<p><strong>æ€»çš„å®ç°ä»£ç å¦‚ä¸‹</strong></p>

<p>tcp_sender.hh</p>
<pre><code class="language-C++">class TCPSender {
  private:
    //! our initial sequence number, the number for our SYN.
    WrappingInt32 _isn;

    //! outbound queue of segments that the TCPSender wants sent
    std::queue&lt;TCPSegment&gt; _segments_out{};
    std::queue&lt;TCPSegment&gt; _segments_waiting{};
    //! retransmission timer for the connection
    unsigned int _initial_retransmission_timeout;

    ByteStream _stream;

    uint64_t _next_seqno{0}; // ä¸‹ä¸€ä¸ªå°†è¢«å‘é€çš„å­—èŠ‚åºå·
    uint64_t _ack_seqno{0}; // æœ€å¤§çš„è¢«ç¡®è®¤çš„å­—èŠ‚åºå·
    uint64_t _win_size{1};
    size_t _consecutive_retransmission{0};
    unsigned int _total_time{0};
    unsigned int _retransmisson_timeout{0};
    bool _is_timer_running{false};
    bool _is_syn{false};
    bool _is_fin{false};
    bool _win_zero_flag{false};
    
  public:
    //! Initialize a TCPSender
    TCPSender(const size_t capacity = TCPConfig::DEFAULT_CAPACITY,
              const uint16_t retx_timeout = TCPConfig::TIMEOUT_DFLT,
              const std::optional&lt;WrappingInt32&gt; fixed_isn = {});


    ByteStream &amp;stream_in() { return _stream; }
    const ByteStream &amp;stream_in() const { return _stream; }

    std::queue&lt;TCPSegment&gt; &amp;segments_waiting() { return _segments_waiting; }
    const std::queue&lt;TCPSegment&gt; &amp;segments_waiting() const { return _segments_waiting; }


    void ack_received(const WrappingInt32 ackno, const uint16_t window_size);

    void send_empty_segment();


    void fill_window();

    void tick(const size_t ms_since_last_tick);

    size_t bytes_in_flight() const;

    unsigned int consecutive_retransmissions() const;

    std::queue&lt;TCPSegment&gt; &amp;segments_out() { return _segments_out; }

    uint64_t next_seqno_absolute() const { return _next_seqno; }

    WrappingInt32 next_seqno() const { return wrap(_next_seqno, _isn); }
};
</code></pre>

<p>tcp_sender.cc</p>
<pre><code class="language-C++">TCPSender::TCPSender(const size_t capacity, const uint16_t retx_timeout, const std::optional&lt;WrappingInt32&gt; fixed_isn)
    : _isn(fixed_isn.value_or(WrappingInt32{random_device()()}))
    , _initial_retransmission_timeout{retx_timeout}
    , _stream(capacity)
    , _retranmisson_timeout(retx_timeout) {}

uint64_t TCPSender::bytes_in_flight() const { return _next_seqno - _ack_seqno; }

void TCPSender::fill_window() {
    if (_win_size == 0 || _is_fin) {
        return;
    }
    TCPSegment seg;
    if (!_is_syn) {
        // only send a syn flag in order to handshake
        _is_syn = true;
        seg.header().syn = true;
        seg.header().seqno = next_seqno();
        _next_seqno++;
        _win_size--;
        segments_out().push(seg);
        segments_waiting().push(seg);
    } else if (stream_in().eof()) {
        // only send a fin flag
        _is_fin = true;
        seg.header().fin = true;
        seg.header().seqno = next_seqno();
        _next_seqno++;
        _win_size--;
        segments_out().push(seg);
        segments_waiting().push(seg);
    } else {
        // send the normal payload
        while (_win_size &gt; 0 &amp;&amp; !stream_in().buffer_empty()) {
            seg.header().seqno = next_seqno();
            uint64_t send_len = min(_win_size, min(TCPConfig::MAX_PAYLOAD_SIZE, stream_in().buffer_size()));
            seg.payload() = stream_in().read(send_len);
            if (seg.length_in_sequence_space() &lt; _win_size &amp;&amp; stream_in().eof()) {
                _is_fin = true;
                seg.header().fin = true;
            }
            _next_seqno += seg.length_in_sequence_space();
            _win_size -= seg.length_in_sequence_space();
            segments_out().push(seg);
            segments_waiting().push(seg);
        }
    }
    if (!_is_timer_running) {
        // start timer
        _is_timer_running = true;
        _total_time = 0;
    }
}

//! \param ackno The remote receiver's ackno (acknowledgment number)
//! \param window_size The remote receiver's advertised window size
void TCPSender::ack_received(const WrappingInt32 ackno, const uint16_t window_size) {
    uint64_t ack_abs = unwrap(ackno, _isn, _next_seqno);
    _win_size = window_size;
    if (ack_abs &gt; _next_seqno || ack_abs &lt;= _ack_seqno)
        return;

    _retranmisson_timeout = _initial_retransmission_timeout;
    _consecutive_retransmission = 0;
    while (!segments_waiting().empty()) {
        TCPSegment seg = segments_waiting().front();
        uint64_t seqno = unwrap(seg.header().seqno, _isn, _next_seqno) + seg.length_in_sequence_space();
        if (seqno &lt;= ack_abs) {
            _ack_seqno = seqno;
            segments_waiting().pop();
        } else
            break;
    }
    if (!segments_waiting().empty()) {
        // restart timer
        _total_time = 0;
        _is_timer_running = true;
    }
    //å¦‚æœæ²¡æœ‰å‘é€ä½†æœªç¡®è®¤çš„æŠ¥æ–‡ï¼Œå…³é—­è®¡æ—¶å™¨
    if (bytes_in_flight() == 0) {
        _is_timer_running = false;
    }
    if (bytes_in_flight() &gt; window_size) {
        //å½“å‘é€ä¸­çš„æ•°æ®å¤§äºçª—å£å°ºå¯¸æ—¶ï¼Œæš‚åœå‘é€æ–°æ•°æ®
        _win_size = 0;
        _win_zero_flag = true;
        return;
    }
    if (_win_size == 0) {
        _win_zero_flag = true;
        _win_size = 1;
    } else {
        _win_zero_flag = false;
    }
    fill_window();
}

//! \param[in] ms_since_last_tick the number of milliseconds since the last call to this method
void TCPSender::tick(const size_t ms_since_last_tick) {
    _total_time += ms_since_last_tick;

    if (_total_time &gt;= _retransmisson_timeout &amp;&amp; !segments_waiting().empty()) {
        // only retransmit the head of queue
        segments_out().push(segments_waiting().front());
        if (!_win_zero_flag) {
            _consecutive_retransmission++;
            _retranmisson_timeout *= 2;
        }
        _total_time = 0;
    }
    if (segments_waiting().empty()) {
        _is_timer_running = false;
    }
}

unsigned int TCPSender::consecutive_retransmissions() const { return _consecutive_retransmission; }

void TCPSender::send_empty_segment() {
    TCPSegment seg;
    seg.header().seqno = next_seqno();
    segments_out().push(seg);
}

</code></pre>

<p><img src="https://pic4.zhimg.com/80/v2-80b67f3dc69aa460e5576d6469cf7f97.png" alt="" /></p>

<p><img src="https://pic4.zhimg.com/80/v2-72024915e556c8540706a383437d64c7.png" alt="" /></p>

<h2 id="å°ç»“">å°ç»“</h2>

<p>è¿™æ¬¡çš„ Lab æ˜æ˜¾æ¯”å‰å‡ æ¬¡çš„éš¾åº¦æå‡äº†ä¸€ä¸ªæ¡£æ¬¡ã€‚å®Œå…¨è¯»é€šæ–‡æ¡£çš„è¦æ±‚å°±æŒºè´¹ç²¾åŠ›çš„äº†ï¼Œç­‰åˆ°å…·ä½“çš„ä»£ç å®ç°ï¼Œåˆå¼€å§‹ä¸çŸ¥æ‰€æªäº†ã€‚å‹‰å‹‰å¼ºå¼ºå†™å®Œæœ€ååˆæ˜¯ä¸€å †é”™è¯¯ï¼Œè¿å†™å¸¦è°ƒï¼ˆä¸­é—´ä¹Ÿå‚è€ƒäº†ä¸€ä¸‹åˆ«äººçš„æ€è·¯ï¼‰èŠ±æ‰äº†å¿«ä¸¤å¤©æ—¶é—´ï¼Œç»ˆäºè¿‡äº†æµ‹è¯•ï¼Œè™½ç„¶æ„Ÿè§‰è‡ªå·±çš„ä»£ç éå¸¸çš„ä¸‘é™‹qwqã€‚ä¸å¾—ä¸è¯´ï¼Œéšç€å®éªŒçš„æ·±å…¥ï¼Œè¦è€ƒè™‘çš„ç»†èŠ‚è¶Šæ¥è¶Šå¤šäº†ï¼Œè™½ç„¶åªæ˜¯ä¸ªç®€æ˜“çš„ TCPï¼Œä½†æ˜¯å¯¹äºå„ç§è¾¹è¾¹è§’è§’çš„æƒ…å†µéƒ½éœ€è¦è€ƒè™‘åˆ°ï¼Œè¿™å‡ å¤©åŸºæœ¬å°±æŒ‡ç€æµ‹è¯•æ¥å¸®æˆ‘æ‰¾å‘äº†ã€‚ã€‚</p>

<p>ç»ˆäºåªå‰©ä¸‹æœ€åä¸€ä¸ª Lab äº†ï¼Œè™½ç„¶ Lab4 çš„å˜æ€ç¨‹åº¦æ—©å·²å¬é—»ã€‚ã€‚ä¸è¿‡ä¸è¦æ€•ï¼Œèƒœåˆ©å°±åœ¨çœ¼å‰ï¼Œå¹²å°±å®Œäº‹äº†ï¼</p>
:ET