I"ßD<blockquote>
  <p>æœ¬æ–‡ä¸ºæ–¯å¦ç¦å¤§å­¦è®¡ç®—æœºç½‘ç»œè¯¾ç¨‹ CS144 ç¼–ç¨‹ä»»åŠ¡ Lab Assignment 4 çš„å­¦ä¹ å°ç»“</p>

  <p>å®˜ç½‘ https://cs144.github.io/</p>

  <p>Lab 4 æ–‡æ¡£ https://cs144.github.io/assignments/lab4.pdf</p>

  <p>ä¸ªäººå®éªŒå¤‡ä»½ä»£ç  https://github.com/deepzheng/sponge</p>
</blockquote>

<hr />

<p>TCPConnection éœ€è¦å®Œæˆä»¥ä¸‹ä¸‰å¤§åŠŸèƒ½</p>

<ul>
  <li>
    <p>æ¥æ”¶æŠ¥æ–‡</p>

    <ul>
      <li>
        <p>å¦‚æœæ¥æ”¶åˆ°çš„æŠ¥æ–‡æ®µè®¾ç½®äº†é‡ç½®æ ‡å¿—<code class="language-plaintext highlighter-rouge">RST</code>ï¼Œå°†å…¥æ ˆå’Œå‡ºæ ˆçš„æµéƒ½è®¾æˆé”™è¯¯çŠ¶æ€å¹¶ kill æ‰è¿æ¥</p>
      </li>
      <li>å°†æŠ¥æ–‡æ®µæä¾›ç»™ TCPReceiver åšè¿›ä¸€æ­¥çš„å¤„ç†</li>
      <li>å¦‚æœæ¥æ”¶åˆ°çš„æŠ¥æ–‡æ®µè®¾ç½®äº†ç¡®è®¤æ ‡å¿—<code class="language-plaintext highlighter-rouge">ACK</code>ï¼Œå°† <code class="language-plaintext highlighter-rouge">ackno</code> å’Œ<code class="language-plaintext highlighter-rouge">window_size</code>å­—æ®µä¼ é€ç»™ TCPSender</li>
      <li>å¦‚æœä¼ å…¥çš„æŠ¥æ–‡æ®µå ç”¨äº†åºåˆ—å·ï¼ŒTCPConnection åº”è¯¥ç¡®ä¿è‡³å°‘å‘é€ä¸€ä¸ªç”¨äºå›å¤çš„æŠ¥æ–‡æ®µä»¥ç¡®ä¿å¯¹æ–¹çš„<code class="language-plaintext highlighter-rouge">ackno</code>å’Œ<code class="language-plaintext highlighter-rouge">window_size</code>èƒ½å¾—åˆ°æ›´æ–°</li>
    </ul>
  </li>
  <li>
    <p>å‘é€æŠ¥æ–‡</p>

    <ul>
      <li>ä»»ä½•æ—¶å€™ TCPSender éƒ½å°†æŠ¥æ–‡æ®µæ¨å‘å…¶ä¼ å‡ºé˜Ÿåˆ—ï¼Œè®¾ç½®å­—æ®µï¼šï¼ˆ<code class="language-plaintext highlighter-rouge">seqno</code>ï¼Œ<code class="language-plaintext highlighter-rouge">SYN</code>ï¼Œ<code class="language-plaintext highlighter-rouge">payload</code>å’Œ<code class="language-plaintext highlighter-rouge">FIN</code>ï¼‰</li>
      <li>åœ¨å‘é€æŠ¥æ–‡æ®µä¹‹å‰ï¼ŒTCPConnection å°†è¯¢é—® Tcreceiver ä¸ºå…¶è´Ÿè´£ä¼ å‡ºæ®µçš„å­—æ®µï¼šackno å’Œ window_sizeã€‚å¦‚æœæœ‰ä¸€ä¸ªacknoï¼Œå®ƒå°†è®¾ç½® ACK æ ‡å¿—å’ŒTCPSegment ä¸­çš„å­—æ®µ</li>
    </ul>
  </li>
  <li>
    <p>è®°å½•ä¼ è¾“æ—¶é—´</p>

    <ul>
      <li>è°ƒç”¨<code class="language-plaintext highlighter-rouge">tick</code>æ–¹æ³•å‘Šè¯‰ TCPSender è‡ªä»ä¸Šæ¬¡è°ƒç”¨åç»è¿‡çš„æ—¶é—´</li>
      <li>è‹¥è¿ç»­é‡ä¼ æ•°é‡è¶…è¿‡ä¸Šé™ï¼Œç»ˆæ­¢è¿æ¥ï¼Œå‘é€ä¸€ä¸ªé‡ç½®æ®µï¼ˆå¸¦æœ‰<code class="language-plaintext highlighter-rouge">RST</code>æ ‡å¿—çš„ç©ºæ®µï¼‰</li>
      <li>å…³é—­è¿æ¥è‹¥å¿…è¦çš„è¯</li>
    </ul>
  </li>
</ul>

<p><img src="https://pic4.zhimg.com/80/v2-0089cff9d131d761dcba441959a3f6a2.png" alt="" /><br />
ä¸Šå›¾å°±æ˜¯ TCP æŠ¥æ–‡æ®µçš„æ‰€æœ‰å†…å®¹äº†ï¼Œè“è‰²éƒ¨åˆ†ä»£è¡¨å‘é€æ–¹éœ€è¦ä¼ è¾“å’Œè®¾ç½®çš„å†…å®¹ï¼Œçº¢è‰²éƒ¨åˆ†åˆ™ä»£è¡¨ä½œä¸ºæ¥æ”¶è€…æ‰€åé¦ˆç»™å¯¹æ–¹çš„ä¿¡æ¯</p>

<p>ä»»åŠ¡ä¹¦åˆ°è¿™é‡Œå°±ç»“æŸäº†ï¼Œå¾€ä¸‹å°±æ˜¯ FAQs çš„éƒ¨åˆ†äº†ã€‚çœ‹èµ·æ¥å¾ˆç®€å•æ˜¯å§ï¼Œåªè¦æŠŠä¹‹å‰åšè¿‡çš„ Receiver å’Œ Sender æ‹¼æ‹¼å‡‘å‡‘å°±å¥½äº†ã€‚æˆ‘ä»¬è¯•ç€è·‘ä¸€ä¸‹ check</p>

<p>å¥½å®¶ä¼™ 162 ä¸ªæµ‹è¯•ç‚¹ï¼Œæœç„¶æœ‰ç‚¹ä¸œè¥¿ã€‚ã€‚ã€‚</p>

<p>ä¸ç®¡äº†ï¼Œé¥­è¦ä¸€å£ä¸€å£åƒï¼Œè·¯è¦ä¸€æ­¥ä¸€æ­¥èµ°ï¼Œå…ˆæŠŠä»¥å‰å®ç°çš„èƒ½ç›´æ¥è°ƒç”¨çš„ api å…ˆå¡«ä¸Šå»å§</p>

<pre><code class="language-C++">size_t TCPConnection::remaining_outbound_capacity() const { return _sender.stream_in().remaining_capacity() }  

size_t TCPConnection::bytes_in_flight() const { return _sender.bytes_in_flight(); }  

size_t TCPConnection::unassembled_bytes() const { return _receiver.unassembled_bytes(); }  

</code></pre>
<p>è™½ç„¶ä¸çŸ¥é“å¯¹ä¸å¯¹å§ã€‚ã€‚ã€‚å…ˆè·‘ä¸ªæµ‹è¯•çœ‹çœ‹ï¼ˆä¿¡æ¯å¤ªå¤šäº†è¿˜å¾—è¾“å‡ºåˆ° log æ–‡ä»¶é‡Œé¢çœ‹2333ï¼‰</p>

<p><img src="https://pic4.zhimg.com/80/v2-2eab269ba7ed9debc707f489dcdeb167.png" alt="" /></p>

<p>åŒ…å«æœ‰ SYN çš„è¿æ¥è¯·æ±‚æ˜¯å‘é€äº†ï¼Œä½†æ˜¯å¹¶æ²¡æœ‰å¯¹è¿™ä¸ª SYN çš„ç¡®è®¤æŠ¥æ–‡ï¼Œæ‰€ä»¥å…¶å®è¿™ä¸ª <code class="language-plaintext highlighter-rouge">connect</code>è¿˜åº”è¯¥æœ‰åŒ…å«ç¡®è®¤çš„åº”ç­”ï¼Ÿå¹¶ä¸”çœ‹ warningï¼šUnclean shutdown of TCPConnectionï¼Œæ‰€ä»¥åœ¨å‘å®Œä¸€ä¸ªæŠ¥æ–‡ä¹‹åéœ€è¦ä¸€ä¸ª clean çš„ shutdownã€‚</p>

<p>é‚£ä¹ˆä»€ä¹ˆæ˜¯ clean shutdown ä»€ä¹ˆæ˜¯ unclean shutdown å‘¢ï¼Ÿåœ¨ç¬¬äº”èŠ‚ä»»åŠ¡ä¹¦å‘Šè¯‰æˆ‘ä»¬</p>

<p>åœ¨ unclean shutdown æƒ…å†µä¸‹ï¼Œå‘é€æˆ–æ¥æ”¶çš„æŠ¥æ–‡æ®µåŒ…ä¼šå«æœ‰ RST çš„æ ‡å¿—ï¼Œåœ¨è¿™ä¸ªæ—¶å€™ï¼Œå‡ºç«™å’Œå…¥ç«™çš„å­—èŠ‚æµéƒ½æ˜¯å¤„äºä¸€ä¸ªé”™è¯¯çŠ¶æ€ï¼Œå¹¶ä¸” <code class="language-plaintext highlighter-rouge">active()</code> ä¹Ÿå¤„äº false çŠ¶æ€</p>

<p>åœ¨ clean shutdown æƒ…å†µä¸‹å‘¢ï¼Œè‡ªç„¶å°±æ˜¯åœ¨æ²¡æœ‰é”™è¯¯çš„æƒ…å†µä¸‹å…³é—­è¿æ¥äº†ã€‚ä»€ä¹ˆæ—¶å€™å¯ä»¥ clean shutdown å‘¢ï¼Ÿ</p>

<ol>
  <li>å…¥ç«™å­—èŠ‚æµå·²ç»è¢«å®Œæ•´ç»„è£…</li>
  <li>å‡ºç«™å­—èŠ‚æµå·²ç»è¢«å…¨éƒ¨å‘é€ï¼ˆåŒ…æ‹¬ FIN ï¼‰</li>
  <li>å‡ºç«™å­—èŠ‚æµè¢«æ¥æ”¶æ–¹å…¨éƒ¨ç¡®è®¤</li>
  <li>æœ¬åœ° TCPConnection ç¡®ä¿è¿œç«¯ä¹Ÿæ»¡è¶³æ¡ä»¶ 3ï¼Œå…·ä½“å®ç°å‘¢ï¼Œä»–ç»™äº†ä¸¤ç§æ–¹æ³•
    <ul>
      <li>å½“æ¡ä»¶ 1 åˆ° 3 éƒ½æ»¡è¶³å¹¶ä¸”è‡³å°‘ 10 å€çš„åˆå§‹é‡ä¼ æ—¶é—´å†…æœ¬åœ°éƒ½æ²¡æœ‰æ”¶åˆ°å¯¹æ–¹çš„æ–°æŠ¥æ–‡</li>
      <li><strong>è¢«åŠ¨å…³é—­</strong>ï¼Œä½†æ˜¯è¿™ä¸ªæˆ‘çœ‹çš„ä¸æ˜¯å¤ªæ‡‚ <code class="language-plaintext highlighter-rouge">Prerequisites #1 through #3 are true, and the local peer is 100% certain that the remote peer can satisfy prerequisite #3. How can this be, if TCP doesnâ€™t acknowledge acknowledgments? Because the remote peer was the first one to end its stream.</code></li>
    </ul>
  </li>
</ol>

<p>é™¤æ­¤ä¹‹å¤–ï¼Œè¿˜æœ‰ä¸€ä¸ª <code class="language-plaintext highlighter-rouge">_linger_after_streams_finish</code> å˜é‡ç”¨äºæŒ‡ç¤ºåœ¨å‡ºå…¥æµéƒ½ç»“æŸåæ˜¯å¦è¿˜éœ€è¦ä¿æŒ active çŠ¶æ€ç›´åˆ° 10 å€é‡ä¼ æ—¶é—´ä¹‹åã€‚5.1 ä¸­æåˆ°ï¼Œå½“å…¥ç«™æµåœ¨å‡ºç«™æµåˆ°è¾¾ EOF ä¹‹å‰ç»“æŸçš„è¯ï¼Œè¯¥å˜é‡éœ€è¦è®¾ç½®æˆ false</p>

<p>æ˜ç™½äº†ï¼Œè¿™å°±æŠŠè¿™ä¸¤ä¸ªå‡½æ•°å†™å‡ºæ¥</p>

<pre><code class="language-C++">void TCPConnection::unclean_shutdown(){  
    _active = false;  
    _sender.stream_in().set_error();  
    _receiver.stream_out().set_error();  

    if(!_sender.segments_out().empty()){  
        TCPSegment rst_seg = _sender.segments_out().front();  
        rst_seg.header().rst = true;  
        _segments_out.push(rst_seg);  
        _sender.segments_out().pop();  
    }else{  
      //è‹¥é˜Ÿåˆ—ä¸­æ²¡æœ‰æŠ¥æ–‡æ®µäº†éœ€è¦ç”Ÿæˆä¸€ä¸ªç©ºæŠ¥æ–‡æ®µæ¥å‘é€  
        _sender.send_empty_segment();  
        TCPSegment rst_seg = _sender.segments_out().front();  
        rst_seg.header().rst = true;  
        _segments_out.push(rst_seg);  
        _sender.segments_out().pop();  
    }  

}  

void TCPConnection::clean_shutdown(){  
    if(_receiver.stream_out().input_ended() &amp;&amp; !_sender.stream_in().eof()){  
        _linger_after_streams_finish = false;  
    }  
    if(_receiver.stream_out().input_ended() &amp;&amp; _sender.stream_in().eof() &amp;&amp; _sender.segments_out().empty() &amp;&amp; !_sender.bytes_in_flight()){  
        if(!_linger_after_streams_finish || time_since_last_segment_received() &gt;= 10*_cfg.rt_timeout){  
            _active = false;  
        }  
    }  
}  
</code></pre>
<p>åœ¨ unclean shutdown æƒ…å†µä¸‹ï¼Œå‘é€æ–¹è¿˜éœ€è¦å‘é€ä¸€ä¸ªåŒ…å« RST çš„æŠ¥æ–‡æ®µï¼Œä½†æ˜¯åœ¨ clean shutdown æƒ…å†µä¸‹ï¼Œæœ¬æ¥å°±æ˜¯å·²ç»æ‰€æœ‰çš„æŠ¥æ–‡æ®µå‘é€å®Œäº†æ‰ clean çš„ï¼Œè‡ªç„¶ä¸éœ€è¦å†å‘æ–°çš„æ®µäº†ï¼ŒæŠŠ active çŠ¶æ€å˜æˆ false å°±å¤Ÿäº†</p>

<p>ç„¶ååœ¨ææ„å‡½æ•°é‡Œé¢ï¼Œæ ¹æ®æç¤ºæŠŠunclean shutdown å¡«è¿›å»å°±è¡Œäº†</p>

<pre><code class="language-C++">TCPConnection::~TCPConnection() {  
    try {  
        if (active()) {  
            cerr &lt;&lt; "Warning: Unclean shutdown of TCPConnection\n";  
            unclean_shutdown();  
            // Your code here: need to send a RST segment to the peer  
        }  
    } catch (const exception &amp;e) {  
        std::cerr &lt;&lt; "Exception destructing TCP FSM: " &lt;&lt; e.what() &lt;&lt; std::endl;  
    }  
}  
</code></pre>

<p>å†ç„¶åè¿˜æœ‰å•¥èƒ½å†™çš„å‘¢ã€‚write å¥½åƒçœ‹èµ·æ¥æ¯”è¾ƒç®€å•ï¼Œå…ˆæŠŠè¿™ä¸ªå†™äº†å§</p>
<pre><code class="language-C++">size_t TCPConnection::write(const string &amp;data) {  
    size_t write_length = _sender.stream_in().write(data);  
    _sender.fill_window();  
    while (!_sender.segments_out().empty())  
    {  
        TCPSegment seg = _sender.segments_out().front();  
        if(_receiver.ackno().has_value()){  
            seg.header().ack = true;  
            seg.header().ackno = _receiver.ackno().value();  
            seg.header().win = _receiver.window_size();  
        }  
        _segments_out.push(seg);  
        _sender.segments_out().pop();  
    }  
    return write_length;  
}  
</code></pre>
<p>éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œåœ¨å‘é€æŠ¥æ–‡æ®µçš„æ—¶å€™ï¼Œè¿˜éœ€è¦é™„å¸¦æ¥æ”¶ç«¯çš„ ackno å’Œ window_size æ•°æ®ï¼ˆå¦‚æœå­˜åœ¨çš„è¯ï¼‰</p>

<p>è¿˜æœ‰ tick å‡½æ•°</p>

<p>åœ¨ FAQ ä¸­æœ‰è¿™ä¹ˆä¸€å¥è¯</p>
<blockquote>
  <p><strong>When should I send a segment with the rst flag set?</strong></p>

  <ol>
    <li>
      <p>If the sender has sent too many consecutive retransmissions without success (more<br />
than TCPConfig::MAX RETX ATTEMPTS, i.e., 8).</p>
    </li>
    <li>
      <p>If the TCPConnection destructor is called while the connection is still active<br />
(active() returns true)</p>
    </li>
  </ol>
</blockquote>

<p>ç¬¬äºŒç‚¹æŒ‡çš„å°±æ˜¯ææ„å‡½æ•°é‡Œäº†ï¼Œç¬¬ä¸€ç‚¹å½“é‡ä¼ æ¬¡æ•°è¿‡å¤š unclean shutdown æ”¾åœ¨ tick å‡½æ•°é‡Œé¢å°±å¥½äº†</p>

<pre><code class="language-C++">void TCPConnection::tick(const size_t ms_since_last_tick) {  
    _time_since_last_segment_received += ms_since_last_tick;  
    _sender.tick(ms_since_last_tick);  
    
    if(_sender.consecutive_retransmissions() &gt; _cfg.MAX_RETX_ATTEMPTS){  
        unclean_shutdown();  
    }  

}  
</code></pre>

<p>å†è·‘ä¸€æ¬¡æµ‹è¯•çœ‹çœ‹<br />
<img src="https://pic4.zhimg.com/80/v2-636bb3cbf7733b3c0c6d0ecbe6741382.png" alt="" /><br />
å—¯è¿˜æ˜¯ä¸€æ ·çš„é”™è¯¯ï¼Œå•¥éƒ½æ²¡æœ‰å‘ã€‚ï¼ˆåºŸè¯ï¼Œreceive å‡½æ•°è¿˜æ²¡å†™å‘¢ï¼Œèƒ½å›å¤å‡ºå»å°±æ€ªäº†/æµæ±—é»„è±†ï¼‰</p>

<p>ä¸è¿‡ unclean shutdown çš„ warning å·²ç»æ²¡äº†ï¼Œè¯´æ˜æˆ‘å†™çš„åº”è¯¥æ²¡å•¥é—®é¢˜</p>

<p><img src="https://pic4.zhimg.com/80/v2-65ca165a1edca7d1fafa09d979fe8568.png" alt="Image" /></p>

<p>æ‰¾åˆ°äº†ä¸€å¼ å¾ˆç‰›é€¼çš„çŠ¶æ€è½¬æ¢å›¾ï¼Œå†é…ä¸Šå‰é¢çš„ lab é‡Œé¢ sender å’Œ receiver çš„ FSM ï¼Œé¡ºç€è¿™ä¸ªæ¥åšåº”è¯¥å°±è¡Œäº†å§</p>

<p><img src="https://pic4.zhimg.com/80/v2-d9af3ede0a975e688b9896c21a323f3b.png" alt="Image" /></p>

<p><img src="https://pic4.zhimg.com/80/v2-9929178fd4f4330715ef6549f0971315.png" alt="Image" /></p>

<p>ä¹‹å‰å®ç°çš„ connect æœ‰ç‚¹ç‘•ç–µï¼Œå½“ç”¨äºåŒå‘è¿æ¥çš„æ—¶å€™ï¼Œç¬¬äºŒæ¬¡æ¡æ‰‹åº”è¯¥å¸¦ä¸Šå¯¹äºç¬¬ä¸€æ¬¡æ¡æ‰‹ SYN çš„ç¡®è®¤å·</p>

<pre><code class="language-C++">void TCPConnection::connect() {
    _sender.fill_window();
    TCPSegment seg = _sender.segments_out().front();
    if(_receiver.ackno().has_value()){
        seg.header().ack = true;
        seg.header().ackno = _receiver.ackno().value();
        seg.header().win = _receiver.window_size();
    }
    _segments_out.push(seg);
    _sender.segments_out().pop();
    
} 
</code></pre>
<p>å…ˆæŠŠæ¥æ”¶ SYN çš„éƒ¨åˆ†å†™å‡ºæ¥</p>
<pre><code class="language-C++">void TCPConnection::segment_received(const TCPSegment &amp;seg) {
    if(seg.header().rst)    unclean_shutdown();

    _receiver.segment_received(seg);
    _time_since_last_segment_received = 0;
    //SYN_RECEIVED
    if(seg.header().syn &amp;&amp; _sender.next_seqno_absolute() == 0){
        connect();
    }
 }
</code></pre>
<p>åˆè·‘äº†ä¸€æ¬¡æµ‹è¯•ï¼ŒåˆæŠ¥äº† unclean shutdown çš„ warningã€‚å¯æ˜¯è¿™é‡Œå¹¶ä¸éœ€è¦ unclean shutdown å•Šï¼Ÿéš¾é“æ˜¯æ¯å‘å®Œä¸€æ¬¡æŠ¥æ–‡éƒ½éœ€è¦å…³é—­ä¸€æ¬¡è¿æ¥çš„æ„æ€å—ï¼Ÿæ‰€ä»¥åº”è¯¥åœ¨å‘å®ŒæŠ¥æ–‡åï¼Œå°±ç›´æ¥ clean shutdownäº†</p>

<p>â€”åˆ†å‰²çº¿â€”</p>

<p>ä¸€å¤©åˆè¿‡å»äº†ï¼Œå­å“§å­å“§å†™äº†ä¸€å †åˆåˆ äº†ä¸€å †ï¼Œç»ˆäºè¿‡äº† 43% çš„æµ‹è¯•äº†ã€‚è¿™ç©æ„å±å®æŠ˜ç£¨äººï¼Œæˆ‘å·²ç»æ²¡æœ‰å†™æ€è·¯çš„å¿ƒæƒ…äº†ã€‚ã€‚</p>

<p>ç°åœ¨ ESTABLISHED ä¹‹å‰çš„éƒ¨åˆ†åº”è¯¥å·²ç»æ²¡å•¥é—®é¢˜äº†ï¼Œçœ‹æµ‹è¯•ä¿¡æ¯å¯ä»¥æ­£å¸¸äº¤æ¢æŠ¥æ–‡äº†ã€‚ç°åœ¨å°±æ˜¯æœ¬æ¥åº”è¯¥åœæ­¢å‘é€æŠ¥æ–‡ç­‰å¾…å…³é—­è¿æ¥çš„æ—¶å€™åˆå‘äº†æŠ¥æ–‡æ®µå‡ºå»</p>

<p><img src="https://pic4.zhimg.com/80/v2-c3dab48e43ac41b4d10a37757d3a2a14.png" alt="" /></p>

<p>ç„¶å unclean shutdown çš„ warning ä¾ç„¶åœ¨
<img src="https://pic4.zhimg.com/80/v2-ac22647582fb7ee832136d17b16edf9e.png" alt="Image" /></p>

<pre><code class="language-C++">
size_t TCPConnection::remaining_outbound_capacity() const { return _sender.stream_in().remaining_capacity(); }

size_t TCPConnection::bytes_in_flight() const { return _sender.bytes_in_flight(); }

size_t TCPConnection::unassembled_bytes() const { return _receiver.unassembled_bytes(); }

size_t TCPConnection::time_since_last_segment_received() const { return _time_since_last_segment_received; }

void TCPConnection::segment_received(const TCPSegment &amp;seg) {
    if(!_active)    return ;
    // _receiver.segment_received(seg);
    _time_since_last_segment_received = 0;

    
    //bool syn_recv = _receiver.ackno().has_value() &amp;&amp; !_receiver.stream_out().input_ended();
    bool send_empty = false;

    if(!_receiver.segment_received(seg)){
        send_empty = true;
    }

    bool listen = !_receiver.ackno().has_value();
    bool syn_sent = _sender.next_seqno_absolute() &gt; 0 &amp;&amp; _sender.next_seqno_absolute() == _sender.bytes_in_flight();
    bool fin_sent = _sender.stream_in().eof() &amp;&amp; _sender.next_seqno_absolute() == _sender.stream_in().bytes_written() + 2 &amp;&amp; _sender.bytes_in_flight() &gt; 0;
    
    if(seg.header().rst){
        if(syn_sent &amp;&amp; !seg.header().ack)   return;
        unclean_shutdown();
        return;
    } 

    if(syn_sent &amp;&amp; seg.header().ack &amp;&amp; seg.payload().size() &gt; 0){   return;}

    if(!seg.header().syn &amp;&amp; listen &amp;&amp; _sender.next_seqno_absolute() == 0){
        return;
    }
    // step 2 of 3-way-handshake
    if(seg.header().syn &amp;&amp; listen &amp;&amp; _sender.next_seqno_absolute() == 0){
        connect();
        return;
    }

    if(_sender.next_seqno_absolute() &gt; 0 &amp;&amp; seg.header().ack){
        if(_sender.ack_received(seg.header().ackno,seg.header().win)){
            send_empty = true;
        }
    }
    

    if(seg.length_in_sequence_space() &gt; 0){
        send_empty = true;
    }
    
    if(send_empty){
        if(!fin_sent &amp;&amp; _receiver.ackno().has_value() &amp;&amp; _sender.segments_out().empty()){
            _sender.send_empty_segment();
        }
    }
    send_segment();
    
 }

bool TCPConnection::active() const { return _active; }

size_t TCPConnection::write(const string &amp;data) {
    size_t write_length = _sender.stream_in().write(data);
    send_segment();
    return write_length;
}

//! \param[in] ms_since_last_tick number of milliseconds since the last call to this method
void TCPConnection::tick(const size_t ms_since_last_tick) {
    if(!_active)    return ;
    _time_since_last_segment_received += ms_since_last_tick;
    _sender.tick(ms_since_last_tick); 
    
    if(_sender.consecutive_retransmissions() &gt; _cfg.MAX_RETX_ATTEMPTS){
        unclean_shutdown();
    }
    send_segment();

}

void TCPConnection::end_input_stream() {
    if(!_active)    return;
    _sender.stream_in().end_input();
    send_segment();
    }

void TCPConnection::connect() {
    if(!_active)    return;
    _sender.fill_window();
    TCPSegment seg = _sender.segments_out().front();
    if(_receiver.ackno().has_value()){
        seg.header().ack = true;
        seg.header().ackno = _receiver.ackno().value();
        seg.header().win = _receiver.window_size();
    }
    _segments_out.push(seg);
    _sender.segments_out().pop();
    clean_shutdown();
}


void TCPConnection::send_segment(){
    if(!_active)    return;
    _sender.fill_window();
    while (!_sender.segments_out().empty())
    {
        TCPSegment send = _sender.segments_out().front();
        if(_receiver.ackno().has_value()){
            send.header().ack = true;
            send.header().ackno = _receiver.ackno().value();
            send.header().win = _receiver.window_size();
        }
        _segments_out.push(send);
        _sender.segments_out().pop();
    } 
    clean_shutdown();
}


void TCPConnection::unclean_shutdown(){
    _active = false;
    _sender.stream_in().set_error();
    _receiver.stream_out().set_error();

    if(!_sender.segments_out().empty()){
        TCPSegment rst_seg = _sender.segments_out().front();
        rst_seg.header().rst = true;
        _segments_out.push(rst_seg);
        _sender.segments_out().pop();
    }else{
        _sender.send_empty_segment();
        TCPSegment rst_seg = _sender.segments_out().front();
        rst_seg.header().rst = true;
        _segments_out.push(rst_seg);
        _sender.segments_out().pop();
    }

}

void TCPConnection::clean_shutdown(){
    if(_receiver.stream_out().input_ended() &amp;&amp; !_sender.stream_in().eof()){
        _linger_after_streams_finish = false;
    }
    if(_receiver.stream_out().input_ended() &amp;&amp; _sender.stream_in().eof() &amp;&amp; _sender.segments_out().empty() &amp;&amp; !_sender.bytes_in_flight()){
        if(!_linger_after_streams_finish || time_since_last_segment_received() &gt;= 10*_cfg.rt_timeout){
            _active = false;
        }
    }
}

TCPConnection::~TCPConnection() {
    try {
        if (active()) {
            cerr &lt;&lt; "Warning: Unclean shutdown of TCPConnection\n";
            unclean_shutdown();
            // Your code here: need to send a RST segment to the peer
        }
    } catch (const exception &amp;e) {
        std::cerr &lt;&lt; "Exception destructing TCP FSM: " &lt;&lt; e.what() &lt;&lt; std::endl;
    }
}

</code></pre>
:ET