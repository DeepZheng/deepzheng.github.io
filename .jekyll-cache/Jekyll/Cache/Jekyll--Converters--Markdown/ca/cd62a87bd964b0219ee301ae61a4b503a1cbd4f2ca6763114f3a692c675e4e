I"–%<blockquote>
  <p>æœ¬æ–‡ä¸ºæ–¯å¦ç¦å¤§å­¦è®¡ç®—æœºç½‘ç»œè¯¾ç¨‹ CS144 ç¼–ç¨‹ä»»åŠ¡ Lab Assignment 0 çš„å­¦ä¹ å°ç»“</p>

  <p>å®˜ç½‘ https://cs144.github.io/</p>

  <p>Lab 0 æ–‡æ¡£ https://cs144.github.io/assignments/lab0.pdf</p>

  <p>ä¸ªäººå®éªŒå¤‡ä»½ä»£ç  https://github.com/deepzheng/sponge</p>
</blockquote>

<hr />

<h2 id="ç¯å¢ƒçš„å®‰è£…ä¸é…ç½®">ç¯å¢ƒçš„å®‰è£…ä¸é…ç½®</h2>

<p>å®˜æ–¹æ–‡æ¡£æä¾›äº†ä¸‰ç§æ”¯æŒè¿è¡Œè¯¥ Lab çš„é€‰æ‹©</p>

<p>æˆ‘è¿˜æ˜¯æ¯”è¾ƒæ¨èä½¿ç”¨è¯¾ç¨‹ç»„æä¾›çš„ VirtualBox çš„é•œåƒçš„</p>

<p>æœ¬æ¥æˆ‘å«Œéº»çƒ¦ï¼Œç”¨è‡ªå·±çš„ Vmware + UBuntu20.04 è‡ªå·±æ¥é…ç½®ç¯å¢ƒï¼Œç»“æœåœ¨åšåˆ°ç¬¬ä¸‰æ­¥è¿è¡Œæµ‹è¯•ä»£ç  <code class="language-plaintext highlighter-rouge">make check_webget</code> çš„æ—¶å€™å‘ç°æŠ¥å‡ºäº†ç¦»å¥‡çš„é”™è¯¯ã€‚æŠŠä»£ç è¿˜åŸåˆ°æ”¹åŠ¨ä¹‹å‰ä¾ç„¶æŠ¥é”™ï¼Œç¿»éå…¨ç½‘ä¹Ÿæ²¡æœ‰æ‰¾åˆ°è§£å†³åŠæ³•ã€‚</p>

<p><img src="https://pic4.zhimg.com/80/v2-b42d2b58d9410a33250215b1d0f55ecb.png" alt="æ˜¯CMakeå‡ºäº†é—®é¢˜ï¼Ÿï¼Ÿä¸å¤ªæ¸…æ¥š" /></p>

<p>æœ€ååªèƒ½ç°æºœæºœåœ°ä¸‹è½½äº† VirtualBox å’Œè¯¾ç¨‹ç»„çš„ LUBuntu é•œåƒã€‚ä¹‹å‰ä»æ²¡ç”¨è¿‡lUBuntu çš„æˆ‘çœ‹åˆ°ç±» Windows çš„ç•Œé¢è¿˜æ˜¯æœ‰ç‚¹åˆ«æ‰­2333 å¥½åœ¨åŸºæœ¬æ“ä½œå¤§å·®ä¸å·®</p>

<h2 id="networking-by-hand">Networking by hand</h2>

<p>è¿™éƒ¨åˆ†å†…å®¹æ¯”è¾ƒç®€å•ï¼Œè·Ÿç€æ–‡æ¡£ä¸€æ­¥æ­¥åšå°±å¥½äº†</p>

<h3 id="fetch-a-web-page">Fetch a Web page</h3>

<p>ä½¿ç”¨ telnet å‘é€ http è¯·æ±‚ï¼Œå‘½ä»¤ç»“æŸåéœ€è¦ä¸¤æ¬¡å›è½¦ç»“æŸè¯·æ±‚</p>

<p><img src="https://pic4.zhimg.com/80/v2-409ca4a4e660af65011b3df7c62a382f.png" alt="" /></p>

<h3 id="send-youself-an-email">Send youself an email</h3>

<p>å®˜æ–¹æ–‡æ¡£æä¾›çš„æ˜¯æ–¯å¦ç¦æ ¡å†…çš„é‚®ç®±æœåŠ¡å™¨ï¼Œæƒ³è¦å®Œæˆè¿™ä¸ªéƒ¨åˆ†å°±éœ€è¦ä½¿ç”¨å›½å†…çš„é‚®ç®±æœåŠ¡å™¨äº†ï¼Œå¹¶ä¸”æ“ä½œä¸Šä¼šç¨å¾®éº»çƒ¦ä¸€ç‚¹</p>

<p>æˆ‘é€‰ç”¨çš„æ˜¯ QQ çš„é‚®ç®±æœåŠ¡å™¨ï¼Œåœ¨ç™»é™†çš„æ—¶å€™éœ€è¦æä¾›è´¦å·å’Œæ ¡éªŒç çš„ Base64ç¼–ç </p>

<p><img src="https://pic4.zhimg.com/80/v2-3d7b855c6d9004b44d14e8c74063a62a.png" alt="" /></p>

<p><img src="https://pic4.zhimg.com/80/v2-11b0c62368a73a5ff6696137df579a87.png" alt="" /></p>

<h3 id="listening-and-connecting">Listening and connecting</h3>

<p>å¼€ä¸¤ä¸ªç»ˆç«¯åˆ†åˆ«æ¨¡æ‹Ÿå®¢æˆ·ç«¯å’ŒæœåŠ¡å™¨ç«¯æ“ä½œã€‚æœåŠ¡å™¨ç«¯å¼€å¯ç›‘å¬æ¨¡å¼ï¼Œç­‰å¾…å®¢æˆ·ç«¯å»ºç«‹è¿æ¥ä¹‹åï¼Œå°±å¯ä»¥æ”¶åˆ°å¦ä¸€ä¸ªç»ˆç«¯å‘æ¥çš„æ¶ˆæ¯äº†</p>

<p><img src="https://pic4.zhimg.com/80/v2-0f0f3174d423eb9042daebbde6684d4e.png" alt="" /></p>

<h2 id="writing-a-network-program-using-an-os-stream-socket">Writing a network program using an OS stream socket</h2>

<p>è¿™ä¸€ä¸ªéƒ¨åˆ†æ˜¯æœ¬ Lab çš„æ ¸å¿ƒï¼Œéœ€è¦ä½¿ç”¨ OS æµå¥—æ¥å­—ç¼–å†™å®ç°ä¸€ä¸ªget_URLå‡½æ•°ä»¥åŠå®Œæˆä¸€ä¸ªå­—èŠ‚æµæ§åˆ¶è¯»å†™ç±»</p>

<h3 id="writing-webget">Writing webget</h3>
<p>æ¨¡æ‹Ÿä¸Šé¢ telnet çš„æ“ä½œï¼Œä½¿ç”¨å¥—æ¥å­—ç¼–å†™ get_URL å‡½æ•°å®ç° webget ã€‚</p>

<p><code class="language-plaintext highlighter-rouge">web_get.cc</code></p>

<pre><code class="language-C++">void get_URL(const string &amp;host, const string &amp;path) {
    // Your code here.
    TCPSocket sock{};
    sock.connect(Address(host,"http"));
    string message = "GET " + path + " HTTP/1.1\r\nHOST: " + host + "\r\n\r\n";
    sock.write(message);
    sock.shutdown(SHUT_WR);
    while( !sock.closed() &amp;&amp; !sock.eof()){
        //é€šè¿‡ eof åˆ¤æ–­æ˜¯å¦å·²ç»è¯»åˆ°äº†æœ€æœ«å°¾ï¼Œè‹¥æ²¡æœ‰åˆ™è¯»å–ç»§ç»­
        cout &lt;&lt; sock.read();
    }
    sock.close();
    return ;

    cerr &lt;&lt; "Function called: get_URL(" &lt;&lt; host &lt;&lt; ", " &lt;&lt; path &lt;&lt; ").\n";
    cerr &lt;&lt; "Warning: get_URL() has not been implemented yet.\n";
}
</code></pre>

<p><img src="https://pic4.zhimg.com/80/v2-b1ef21ee9e774f5c37722ce91dc512dc.png" alt="æµ‹è¯•é€šè¿‡" /></p>

<blockquote>
  <p>tips:</p>

  <ul>
    <li>TCP åœ¨å»ºç«‹è¿æ¥æ—¶ä¼šç”±ç³»ç»Ÿéšå½¢ bind ç«¯å£ï¼Œä¸éœ€è¦åƒ UDP ä¸€æ ·æ‰‹åŠ¨æ“ä½œ</li>
    <li>ç›¸æ¯”äº<code class="language-plaintext highlighter-rouge">close()</code>,<code class="language-plaintext highlighter-rouge">shutdown()</code> æä¾›äº†ä¸€ä¸ªæ›´ä¸ºä¼˜é›…çš„æ“ä½œæ–¹å¼ã€‚è°ƒç”¨ <code class="language-plaintext highlighter-rouge">close()</code> å‡½æ•°æ„å‘³ç€å®Œå…¨æ–­å¼€è¿æ¥ï¼Œå³ä¸èƒ½å‘é€æ•°æ®ä¹Ÿä¸èƒ½æ¥æ”¶æ•°æ®ã€‚è€Œ <code class="language-plaintext highlighter-rouge">shutdown()</code> æä¾›äº†ä¸‰ä¸ªå˜é‡å–å€¼
      <blockquote>
        <ul>
          <li>SHUT_RD æ–­å¼€è¾“å…¥æµ</li>
          <li>SHUT_WR æ–­å¼€è¾“å‡ºæµ</li>
          <li>SHUT_RDWR åŒæ—¶æ–­å¼€ I/O æµ</li>
        </ul>
      </blockquote>
    </li>
    <li>é»˜è®¤æƒ…å†µä¸‹ï¼Œè°ƒç”¨ <code class="language-plaintext highlighter-rouge">close()</code> åæ— è®ºè¾“å…¥ç¼“å†²åŒºä¸­æ˜¯å¦æœ‰æ•°æ®éƒ½å°†ç«‹å³å…³é—­å¥—æ¥å­—ï¼Œåç»­éœ€è¦å‘é€æ•°æ®éœ€è¦å†æ¬¡å»ºç«‹å¥—æ¥å­—è¿æ¥ã€‚è€Œ<code class="language-plaintext highlighter-rouge">shutdown()</code> åªç”¨äºå…³é—­è¿æ¥è€Œéå¥—æ¥å­—ï¼Œå¹¶ä¸” <code class="language-plaintext highlighter-rouge">shutdown()</code> ä¼šç­‰å¾…è¾“å…¥ç¼“å†²åŒºä¸­çš„æ•°æ®ä¼ è¾“å®Œæˆåå†å…³é—­è¿æ¥</li>
  </ul>
</blockquote>

<h3 id="an-in-memory-reliable-byte-stream">An in-memory reliable byte stream</h3>

<p>è¯¥éƒ¨åˆ†éœ€è¦å®ç°ä¸€ä¸ªç®€å•çš„å¯é å­—èŠ‚æµç±»ï¼Œæ”¯æŒå†™å…¥ã€è¯»å‡ºã€å®¹é‡æ§åˆ¶ã€æµé‡è®¡ç®—</p>

<p>å¯¹äºå­—èŠ‚æµç¼“å†²åŒºçš„æ•°æ®ç»“æ„ï¼Œæœ¬æ¥æˆ‘æ˜¯æƒ³ä½¿ç”¨<code class="language-plaintext highlighter-rouge">string</code>æ¥è¿›è¡ŒåŒå‘è¯»å†™ï¼Œä½†æ˜¯æŒ‰ç…§ç°ä»£C++dçš„è¦æ±‚ï¼Œåº”è¯¥å°½å¯èƒ½é¿å…ä½¿ç”¨æŒ‡é’ˆï¼Œè€Œ string ä¸‹æ ‡çš„ç´¢å¼•æœ¬è´¨ä¸Šè¿˜æ˜¯æŒ‡é’ˆï¼Œæ‰€ä»¥æˆ‘æœ€åä½¿ç”¨äº† <code class="language-plaintext highlighter-rouge">deque</code> åŒå‘é˜Ÿåˆ—ã€‚åŒå‘é˜Ÿåˆ—æ”¯æŒå¤´å°¾è¯»å†™ï¼Œåˆšå¥½å¯¹åº”å­—èŠ‚æµä»å°¾éƒ¨å†™å…¥ä»å¤´éƒ¨è¯»å–çš„ç‰¹æ€§ï¼Œå¹¶ä¸”æ‹¥æœ‰è¿­ä»£å™¨ï¼Œå®Œç¾æ”¯æŒäº†è¯¥å­—èŠ‚æµç±»ä¸­çš„ peek æ“ä½œ</p>

<p><code class="language-plaintext highlighter-rouge">byte_stream.hh</code></p>
<pre><code class="language-C++">#ifndef SPONGE_LIBSPONGE_BYTE_STREAM_HH
#define SPONGE_LIBSPONGE_BYTE_STREAM_HH

#include &lt;string&gt;
#include &lt;deque&gt;

//! Bytes are written on the "input" side and read from the "output"
//! side.  The byte stream is finite: the writer can end the input,
//! and then no more bytes can be written.
class ByteStream {
  private:
    // Your code here -- add private members as necessary.    
    std::deque &lt;char&gt; Stream = {};
    size_t Capacity = 0;
    size_t written_byte = 0;
    size_t read_byte = 0;
    bool is_end_input = false;
    // Hint: This doesn't need to be a sophisticated data structure at
    // all, but if any of your tests are taking longer than a second,
    // that's a sign that you probably want to keep exploring
    // different approaches.

    bool _error{};  //!&lt; Flag indicating that the stream suffered an error.

  public:
    //è¿™éƒ¨åˆ†ä¸éœ€è¦ç¼–è¾‘ï¼Œç•¥å»

#endif  // SPONGE_LIBSPONGE_BYTE_STREAM_HH

</code></pre>

<p><code class="language-plaintext highlighter-rouge">byte_stream.cc</code></p>
<pre><code class="language-C++">#include "byte_stream.hh"

// Dummy implementation of a flow-controlled in-memory byte stream.

// For Lab 0, please replace with a real implementation that passes the
// automated checks run by `make check_lab0`.

// You will need to add private members to the class declaration in `byte_stream.hh`
using namespace std;

ByteStream::ByteStream(const size_t capacity) : Capacity(capacity) {}

// å‘é˜Ÿåˆ—ä¸­å†™å…¥data
size_t ByteStream::write(const string &amp;data) {
    size_t write_length = data.length();
    if(write_length &gt; Capacity - Stream.size()){
        //compared with left room
        write_length = Capacity - Stream.size();
    }
    for(size_t i = 0;i &lt; write_length;i++){
        Stream.emplace_back(data[i]);
    }
    written_byte += write_length;
    return write_length;
}

//! \param[in] len bytes will be copied from the output side of the buffer
// ä»å¤´éƒ¨è¯»å– len é•¿åº¦çš„å­—èŠ‚
string ByteStream::peek_output(const size_t len) const {
    string output_string;
    for(size_t i = 0;i &lt; len &amp;&amp; i &lt; Stream.size();i++){
        output_string.push_back(Stream.at(i));
    }
    return output_string;
}

//! \param[in] len bytes will be removed from the output side of the buffer
// å°†å¤´éƒ¨ len é•¿åº¦å­—èŠ‚ç§»é™¤å­—èŠ‚æµ
void ByteStream::pop_output(const size_t len) {
    size_t pop_length = len &gt; Stream.size() ? Stream.size(): len;
    read_byte += pop_length;
    while(pop_length --){
        Stream.pop_front();
    }
}

//! Read (i.e., copy and then pop) the next "len" bytes of the stream
//! \param[in] len bytes will be popped and returned
//! \returns a string
// è¯»å–ï¼ˆç›¸å½“äºpeekå’Œpopæ“ä½œçš„ç»“åˆï¼‰
std::string ByteStream::read(const size_t len) {
    size_t read_length = len &gt; Stream.size() ? Stream.size() : len;
    string read_string = peek_output(read_length);
    pop_output(read_length);
    return read_string;
}

void ByteStream::end_input() {  is_end_input = true;}

bool ByteStream::input_ended() const { return is_end_input; }

size_t ByteStream::buffer_size() const { return Stream.size(); }

bool ByteStream::buffer_empty() const { return Stream.empty(); }

bool ByteStream::eof() const { return Stream.empty() &amp;&amp; is_end_input; }

size_t ByteStream::bytes_written() const { return written_byte ; }

size_t ByteStream::bytes_read() const { return read_byte; }

size_t ByteStream::remaining_capacity() const { return Capacity - Stream.size(); }

</code></pre>

<p><img src="https://pic4.zhimg.com/80/v2-28da27c8c4074258b238a8b12677dc32.png" alt="æµ‹è¯•é€šè¿‡" /></p>

<p>ä»»åŠ¡ç»“æŸï¼Œæ”¶å·¥å¤§å‰</p>
:ET